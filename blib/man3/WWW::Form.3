.\" Automatically generated by Pod::Man version 1.02
.\" Thu Apr 17 23:16:47 2003
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Form 3"
.TH Form 3 "perl v5.6.0" "2003-04-17" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1WWW:\s0:Form \- Simple and extendable \s-1OO\s0 module for form validation and display
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Simple and easily extendable module that allows developers to handle form
programming flexibly and consistently.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module:
.Ip "\(bu provides functionality to handle all of the various types of \s-1HTML\s0 form inputs this includes displaying \s-1HTML\s0 for the various form inputs)" 4
.IX Item "provides functionality to handle all of the various types of HTML form inputs this includes displaying HTML for the various form inputs)"
.Ip "\(bu handles populating form inputs with user entered data or progammer specified default values" 4
.IX Item "handles populating form inputs with user entered data or progammer specified default values"
.Ip "\(bu provides robust validation of user entered input" 4
.IX Item "provides robust validation of user entered input"
.Ip "\(bu handles presenting customizable error feedback to users" 4
.IX Item "handles presenting customizable error feedback to users"
.Ip "\(bu is easily extended, the \s-1WWW:\s0:Form module is designed to be easily inherited from, so you can add your own features." 4
.IX Item "is easily extended, the WWW::Form module is designed to be easily inherited from, so you can add your own features."
.PP
The most time consuming process (and it's not too bad) is creating the data
structure used for instantiating a \s-1WWW:\s0:Form object.  Once you have a \s-1WWW:\s0:Form object
almost all your work is done, as it will have enough information to handle
just about everything.
.PP
Before we get too involved in the details, let's take a look at a sample
usage of the \s-1WWW:\s0:Form module in a typical setting. Note: If you're using
Apache::Request and mod_perl then your code would look a little different,
but not in how the \s-1WWW:\s0:Form module is used, however.
.PP
.Vb 3
\&    #!/usr/bin/perl
\&    use strict;
\&    use warnings;
.Ve
.Vb 5
\&    use CGI;
\&    use WWW::Form;
\&    # used by WWW::Form to perform various
\&    # validations on user entered input
\&    use WWW::FieldValidator;
.Ve
.Vb 3
\&    # Define values for form input names as constants
\&    use constant EMAIL_FIELD_NAME => 'emailAddress';
\&    use constant PASSWORD_FIELD_NAME => 'password';
.Ve
.Vb 2
\&    # gets us access to the HTTP request data
\&    my $q = CGI->new();
.Ve
.Vb 3
\&    # hash ref of HTTP vars
\&    # would be $r->param() if you're using mod_perl
\&    my $params = $q->Vars() || {};
.Ve
.Vb 1
\&    my $form = WWW::Form->new(get_form_fields(), $params, [&EMAIL_FIELD_NAME, &PASSWORD_FIELD_NAME]);
.Ve
.Vb 4
\&    # check to see that the form was submitted by the user
\&    # if you're using mod_perl, instead of $ENV{REQUEST_METHOD}
\&    # you'd have $r->method()
\&    if ($form->is_submitted($ENV{REQUEST_METHOD})) {
.Ve
.Vb 2
\&        # validate user entered data
\&        $form->validate_fields();
.Ve
.Vb 7
\&        # if the data was good, do something
\&        if ($form->is_valid()) {
\&            # do some stuff with params because we know the
\&            # user entered data passed all of its
\&            # validation
\&        }
\&    }
.Ve
.Vb 3
\&    # display the HTML web page
\&    print <<HTML;
\&    Content-Type: text/html
.Ve
.Vb 12
\&    <html>
\&    <head>
\&    <title>A Simple HTML Form</title>
\&    </head>
\&    <body>
\&    HTML
\&        # Display the form
\&        $form->get_form_HTML(action => './form_test.pl');
\&    print <<HTML;
\&    </body>
\&    </html>
\&    HTML
.Ve
.Vb 24
\&    # returns data structure suitable for passing
\&    # to WWW::Form object constructor, the keys will
\&    # become the names of the HTML form inputs
\&    sub get_form_fields {
\&        my %fields = (
\&            &EMAIL_FIELD_NAME => {
\&                label        => 'Email address',
\&                defaultValue => 'you@emailaddress.com',
\&                type         => 'text',
\&                validators   => [WWW::FieldValidator->new(
\&                                    WWW::FieldValidator::WELL_FORMED_EMAIL,
\&                                    'Make sure email address is well formed')]
\&            },
\&            &PASSWORD_FIELD_NAME => {
\&                label        => 'Password',
\&                defaultValue => '',
\&                type         => 'password',
\&                validators   => [WWW::FieldValidator->new(
\&                                    WWW::FieldValidator::MIN_STR_LENGTH,
\&                                    'Password must be at least 6 characters', 6)]
\&            }
\&        );
\&        return \e%fields;
\&    }
.Ve
.Sh "Instantiating A \s-1WWW:\s0:Form Object"
.IX Subsection "Instantiating A WWW::Form Object"
As I said, instantiating a form object is the trickiest part.  The \s-1WWW:\s0:Form constructor
takes three parameters.  The first parameter called \f(CW$fieldsData\fR, is a hash
reference that describes how the form should be built.  \f(CW$fieldsData\fR should be keyed
with values that are suitable for using as the value of the form inputs' name
\&\s-1HTML\s0 attributes.  That is, if you call a key of your \f(CW$fieldsData\fR hash 'full_name', then you
will have some type of form input whose name attribute will have the value 'full_name'.
The values of the \f(CW$fieldsData\fR keys (i.e., \f(CW$fieldsData\fR->{$fieldName}) should also
be hash references.  This hash reference will be used to tell the \s-1WWW:\s0:Form module
about your form input.  All of these hash references will be structured similarly,
however, there are a couple of variations to accommodate the various types
of form inputs.  The basic structure is as follows:
.PP
.Vb 8
\& {
\&   label => 'Your name', # UI presentable value that will label the form input
\&   defaultValue => 'Homer Simpson', # if set, the form input will be pre-populated with this value
\&                                    # you could hard code a default value or use a value retrieved
\&                                    # from a data base table, for example.
\&   type => 'text', # the type of form input, i.e. text, checkbox, textarea, etc. (more on this later)
\&   validators => [] # an array ref of various validations that should be performed on the user entered input
\& }
.Ve
So to create a \s-1WWW:\s0:Form object with one text box you would have the following data structure:
.PP
.Vb 10
\& my $fields = {
\&   emailAddress => {
\&     label        => 'Email address',
\&     defaultValue => 'you@emailaddress.com',
\&     type         => 'text',
\&     validators   => [WWW::FieldValidator->new(
\&                        WWW::FieldValidator::WELL_FORMED_EMAIL,
\&                       'Make sure email address is well formed')]
\&            }
\&     };
.Ve
You could then say the following to create that \s-1WWW:\s0:Form object:
.PP
.Vb 1
\&  my $form = WWW::Form->new($fields);
.Ve
Now let's talk about the second parameter.  If a form is submitted, the second parameter
is used.  This parameter should be a hash reference of \s-1HTTP\s0 \s-1POST\s0 parameters. So if the previous
form was submitted you would instantiate the \s-1WWW:\s0:Form object like so:
.PP
.Vb 2
\&  my $params = $r->param(); # or $q->Vars if you're using CGI
\&  my $form   = WWW::Form->new($fields, $params);
.Ve
At this point, let me briefly discuss how to specify validators for your form inputs.
.PP
The validators keys in the \f(CW$fieldsData\fR->{$fieldName} hash reference can be left empty, which means
that the user entered input does not need to be validated at all, or it can take a
comma separated list of \s-1WWW:\s0:FieldValidator objects.  The basic format for a \s-1WWW:\s0:FieldValidator
constructor is as follows:
.PP
.Vb 7
\&  WWW::FieldValidator->new($validatorType,
\&                           $errorFeedbackIfFieldNotValid,
\&                           $otherVarThatDependsOnValidatorType, # optional, depends on type of validator
\&                           # an optional boolean, if input is
\&                           # entered validation is run,
\&                           # if nothing is entered input is OK
\&                           $isOptional)
.Ve
The FieldValidator types are:
.PP
.Vb 5
\&  WWW::FieldValidator::WELL_FORMED_EMAIL
\&  WWW::FieldValidator::MIN_STR_LENGTH
\&  WWW::FieldValidator::MAX_STR_LENGTH
\&  WWW::FieldValidator::REGEX_MATCH
\&  WWW::FieldValidator::USER_DEFINED_SUB
.Ve
So to create a validator for a field that would make sure the input
of said field was a minimum length, if any input was entered you would have:
.PP
.Vb 6
\&  WWW::FieldValidator->new(WWW::FieldValidator::MIN_STR_LENGTH,
\&                           'String must be at least 6 characters',
\&                           6, # input must be at least 6 chars
\&                           # input is only validated if user entered something
\&                           # if field left blank, it's OK
\&                           my $isOptional = 1)
.Ve
Now for the third parameter.  The third parameter is simply
an array reference of the keys of the \f(CW$fieldsData\fR hash, but the order of elements in
the array ref should be the order that you want your form inputs to be displayed in.
This array ref is used by the get_form_HTML method to return a form block that can be
displayed in an \s-1HTML\s0 page.
.PP
.Vb 5
\&  # The third parameter will be used to generate an HTML form
\&  # whose inputs will be in the order of their appearance in the
\&  # array ref, note this is the constructor format you should use when instantiating
\&  # form objects
\&  my $form = WWW::Form($fieldsData, $params, ['name', 'emailAddress', 'password']);
.Ve
.Sh "How To Create All The Various Form Inputs"
.IX Subsection "How To Create All The Various Form Inputs"
The following form input types are supported by the \s-1WWW:\s0:Form module
(these values should be used for the 'type' key of your \f(CW$fieldsData\fR->{$fieldName} hash ref):
.PP
text
password
hidden
checkbox
radio
select
textarea
.PP
The following structure can be used for text, password, hidden, and textarea form inputs:
.PP
.Vb 6
\& $fieldName => {
\&   label => 'Your name',
\&   defaultValue => 'Homer Simpson',
\&   type => 'text',
\&   validators => []
\& }
.Ve
The following structure should be used for radio and select form inputs:
.PP
The data structure for input types radio and select use an array of hash references
alled optionsGroup.  The optionsGroup label is what will be displayed in the select box or
beside the radio button, and the optionsGroup value is the value that will be in the hash of \s-1HTTP\s0
params depending on what the user selects.  To pre-select a select box option or radio
button, set its defaultValue to a value that is found in the optionsGroup hash ref. For
example, if you wanted the option 'Blue' to be selected by default in the example below,
you would set defaultValue to 'blue'.
.PP
.Vb 9
\& $fieldName => {
\&   label        => 'Favorite color',
\&   defaultValue => '',
\&   type         => 'select',
\&   optionsGroup => [{label => 'Green', value => 'green'},
\&                    {label => 'Red',   value => 'red'},
\&                    {label => 'Blue',  value => 'blue'}],
\&   validators   => []
\& }
.Ve
The following structure should be used for checkboxes:
.PP
Note: All checkbox form inputs need a defaultValue to be specified, this is the
value that will be used if the checkbox is checked when the form is submitted.  If
a checkbox is not checked then there will not be an entry for it in the hash of \s-1HTTP\s0
\&\s-1POST\s0 params.  If defaultChecked is 1 the checkbox will be selected by default, if it is
0 it will not be selected by default.
.PP
.Vb 7
\& $fieldName => {
\&   label => 'Do you like spam>',
\&   defaultValue => 'Yes, I love it!',
\&   defaultChecked => 0, # 1 or 0
\&   type => 'checkbox',
\&   validators => []
\& }
.Ve
.Sh "Function Reference"
.IX Subsection "Function Reference"
\&\s-1NOTE:\s0 For style conscious developers all public methods are available
using internalCapsStyle and underscore_separated_style. So 'isSubmitted'
is also available as 'is_submitted', and 'getFieldHTMLRow' is also available
as 'get_field_HTML_row', and so on and so forth.
.SH "new"
.IX Header "new"
Creates a \s-1WWW:\s0:Form object.  \f(CW$fieldsData\fR is a hash reference that describes your \s-1WWW:\s0:Form object. (See
instantiating a \s-1WWW:\s0:Form object above.) \f(CW$fieldsValues\fR (i.e., \f(CW$params\fR below) has keys identical to \f(CW$fieldsData\fR.
\&\f(CW$fieldsValues\fR is a hash reference of \s-1HTTP\s0 \s-1POST\s0 variables.  \f(CW$fieldsOrder\fR is an array reference of \f(CW$fieldsData\fR keys
that is used to determine the order that form inputs are displayed in when \fIgetFormHTML()\fR is called.  If you don't
use this parameter you should use the other public methods provided and display your form inputs by hand.
.PP
.Vb 1
\&  Example:
.Ve
.Vb 3
\&  my $params = $r->param() || {};
\&  my $form;
\&  $form = WWW::Form->new($fieldsData, $params, $fieldsOrder);
.Ve
.SH "validateFields"
.IX Header "validateFields"
Validates field's values input according to the validators (\s-1WWW:\s0:FieldValidators) that
were specified when the \s-1WWW:\s0:Form object was created.  This will also set error feedback as
necessary for form inputs that are not valid.
.PP
Returns hash reference of all the fields that are valid (generally you don't need to use
this for anything though because if all the validation passes you can just use your hash ref
of \s-1HTTP\s0 \f(CW$params\fR, i.e. \f(CW$r\fR->\fIparam()\fR).
.PP
.Vb 1
\&  Example:
.Ve
.Vb 4
\&  if ($form->isSubmitted($r->method)) {
\&    # validate fields because form was POSTed
\&    $form->validateFields();
\&  }
.Ve
.SH "getFields"
.IX Header "getFields"
Returns hash ref of fields data.
.SH "getField"
.IX Header "getField"
Returns hash ref of field data that describes the form
input that corrsponds to the passed \f(CW$fieldName\fR.
.SH "getFieldErrorFeedback"
.IX Header "getFieldErrorFeedback"
Returns an array of all the error feedback (if any) for the specified \f(CW$fieldName\fR.
.PP
The next couple of methods are somewhat miscellaneous.  They may be useful but in general
you shouldn't need them.
.SH "getFieldsOrder"
.IX Header "getFieldsOrder"
Returns array ref of field names in the order
they should be displayed.
.SH "getFieldValue"
.IX Header "getFieldValue"
Returns the current value of the specified \f(CW$fieldName\fR.
.SH "getFieldType"
.IX Header "getFieldType"
Returns value of a field's 'type' key.
.SH "getFieldLabel"
.IX Header "getFieldLabel"
Returns the label associated with the specified \f(CW$fieldName\fR.
.SH "setFieldValue"
.IX Header "setFieldValue"
Sets the value of the specified \f(CW$fieldName\fR to \f(CW$value\fR.  You might use this if you need
to convert a user entered value to some other value.
.SH "isValid"
.IX Header "isValid"
Returns true is all form fields are valid or false otherwise.
.PP
.Vb 1
\&  Example:
.Ve
.Vb 3
\&  if ($form->isSubmitted($r->method)) {
\&    # validate fields because form was POSTed
\&    $form->validateFields($params);
.Ve
.Vb 6
\&    # now check to see if form inputs are all valid
\&    if ($form->isValid()) {
\&        # do some stuff with $params because we know
\&        # the validation passed for all the form inputs
\&    }
\&  }
.Ve
.SH "isSubmitted"
.IX Header "isSubmitted"
Returns true if the \s-1HTTP\s0 request method is \s-1POST\s0.  If for
some reason you're using \s-1GET\s0 to submit
a form then this method won't be of much help.  If you're not using
\&\s-1POST\s0 as the method for submitting your form you may want to
override this in a subclass.
.PP
.Vb 1
\&  Example:
.Ve
.Vb 2
\&  # Returns true if HTTP method is POST
\&  $form->isSubmitted($r->method());
.Ve
.SH "getFieldHTMLRow"
.IX Header "getFieldHTMLRow"
Returns \s-1HTML\s0 to display in a web page.  \f(CW$fieldName\fR is a key of the \f(CW$fieldsData\fR hash
that was used to create a \s-1WWW:\s0:Form object. \f(CW$attributesString\fR is an (optional) arbitrary
string of \s-1HTML\s0 attribute key='value' pairs that you can use to add attributes to the form
input.
.PP
The only caveat for using this method is that it must be called between <table> and </table>
tags.  It produces the following output:
.PP
.Vb 8
\&  <!-- NOTE: The error feedback row(s) are only displayed if the field input was not valid -->
\&  <tr>
\&  <td colspan="2">$errorFeedback</td>
\&  </tr>
\&  <tr>
\&  <td>$fieldLabel</td>
\&  <td>$fieldFormInput</td>
\&  </tr>
.Ve
.Vb 1
\&  Example:
.Ve
.Vb 1
\&  $form->getFieldHTMLRow('name', " size='6' class='formField' ");
.Ve
.SH "getFieldFeedbackHTML"
.IX Header "getFieldFeedbackHTML"
Returns \s-1HTML\s0 error content for each vaildator belonging to \f(CW$fieldName\fR that doesn't pass validation.
.PP
Returns following \s-1HTML:\s0
.PP
.Vb 9
\&  <div class='feedback'>
\&  $validatorOneErrorFeedback
\&  </div>
\&  <div class='feedback'>
\&  $validatorTwoErrorFeedback
\&  </div>
\&  <div class='feedback'>
\&  $validatorNErrorFeedback
\&  </div>
.Ve
Note: If you use this, you should implement a \s-1CSS\s0 class named 'feedback' that styles
your error messages appropriately.
.SH "startForm"
.IX Header "startForm"
Title:     startForm
.PP
Usage:     \f(CW$form\fR->start_form(action => '/some_script',
                             name   => 'MyFormName',
                             attributes => {class => 'MyFormClass'});
.PP
Function:  Returns opening form element.
.PP
Returns:   \s-1HTML\s0 to open a form.
.PP
Arguments: action \- Value of form's action attribute.
.PP
.Vb 1
\&           name - Value that will be used for form's name and id attribute.
.Ve
.Vb 2
\&           attributes - hashref of key value pairs that can be used
\&                        to add arbitrary attributes to the opening form element.
.Ve
.SH "endForm"
.IX Header "endForm"
Returns \s-1HTML\s0 to close form.
.SH "getFormHTML"
.IX Header "getFormHTML"
Title:     get_form_HTML
.PP
Usage:     \f(CW$form\fR->\fIget_form_HTML()\fR;
.PP
Functions: Loops through the fieldsOrder array and builds
           markup for each form input in your form.
.PP
Returns:   Markup that when output will display your form.
.PP
Arguments: action \- Value of form's action attribute.
.PP
.Vb 1
\&           name - Value that will be used for form's name and id attribute.
.Ve
.Vb 2
\&           attributes - hashref of key value pairs that can be used
\&                        to add arbitrary attributes to the opening form element.
.Ve
.Vb 1
\&           submit_label - Optional label for your form's submit button.
.Ve
.Vb 3
\&           submit_name -  Optional Value of your submit button's name attribute.
\&                          This value will also be used for your submit button's id
\&                          attribute.
.Ve
.Vb 2
\&           submit_type - Optional string value, defaults to submit, if you want to
\&                         use an image submit button pass submit_type as 'image'.
.Ve
.Vb 2
\&           submit_src - Optional unless submit_type is 'image' then an image src should be specified
\&                        with submit_src, e.g. submit_src => './img/submit_button.png'.
.Ve
.Vb 1
\&           submit_class - Optional string that specifies a CSS class.
.Ve
.Vb 2
\&           submit_attributes -  Optional hash ref of arbitrary name => 'value'
\&                                attributes.
.Ve
